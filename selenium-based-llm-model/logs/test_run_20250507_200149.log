2025-05-07 20:01:56,127 - INFO - Analyzing https://practicetestautomation.com/practice-test-exceptions/ page...
2025-05-07 20:01:56,441 - DEBUG - Static page metadata: {'title': 'Test Exceptions | Practice Test Automation', 'url': 'https://practicetestautomation.com/practice-test-exceptions/', 'forms': [], 'buttons': [{'tag': 'a', 'text': '', 'id': '', 'type': ''}, {'tag': 'a', 'text': '', 'id': '', 'type': ''}, {'tag': 'button', 'text': '', 'id': '', 'type': 'submit'}, {'tag': 'a', 'text': 'HOME', 'id': '', 'type': ''}, {'tag': 'a', 'text': 'PRACTICE', 'id': '', 'type': ''}, {'tag': 'a', 'text': 'COURSES', 'id': '', 'type': ''}, {'tag': 'a', 'text': 'BLOG', 'id': '', 'type': ''}, {'tag': 'a', 'text': 'CONTACT', 'id': '', 'type': ''}, {'tag': 'button', 'text': '', 'id': 'toggle-navigation', 'type': 'submit'}, {'tag': 'a', 'text': 'Selenium WebDriver with Java for beginners program', 'id': '', 'type': ''}, {'tag': 'input', 'text': '', 'id': '', 'type': 'text'}, {'tag': 'button', 'text': 'Edit', 'id': 'edit_btn', 'type': 'submit'}, {'tag': 'button', 'text': '', 'id': 'save_btn', 'type': 'submit'}, {'tag': 'button', 'text': 'Add', 'id': 'add_btn', 'type': 'submit'}, {'tag': 'a', 'text': 'Practice Test Automation.', 'id': '', 'type': ''}, {'tag': 'a', 'text': 'Privacy Policy', 'id': '', 'type': ''}], 'tables': [], 'key_flows': {'main_navigation': ['https://practicetestautomation.com/', 'https://practicetestautomation.com/practice/', 'https://practicetestautomation.com/courses/', 'https://practicetestautomation.com/blog/', 'https://practicetestautomation.com/contact/'], 'primary_actions': []}}
2025-05-07 20:02:07,928 - INFO - LLM analysis of current page completed
2025-05-07 20:02:07,929 - DEBUG - Raw LLM response: {
    "auth_requirements": {
        "auth_required": false,
        "auth_type": "none",
        "auth_fields": []
    },
    "contact_form_fields": [],
    "main_content": "The page provides a practice environment for reproducing and understanding common Selenium exceptions. It includes test cases for exceptions like NoSuchElementException, ElementNotInteractableException, InvalidElementStateException, StaleElementReferenceException, and TimeoutException. Users can interact with a dynamic list of favorite foods to simulate these exceptions.",
    "key_actions": [
        "Add a new row to the list",
        "Edit an existing row",
        "Save changes to a row",
        "Remove a row",
        "Interact with test cases for Selenium exceptions"
    ],
    "content_hierarchy": {
        "primary_sections": [
            "Test Exceptions Overview",
            "Favorite Foods List Interaction",
            "Test Cases for Selenium Exceptions"
        ],
        "subsections": [
            "Test case 1: NoSuchElementException",
            "Test case 2: ElementNotInteractableException",
            "Test case 3: InvalidElementStateException",
            "Test case 4: StaleElementReferenceException",
            "Test case 5: TimeoutException"
        ]
    },
    "interactive_patterns": {
        "forms": ["dynamic list interaction"],
        "dynamic_elements": [
            "Add button to dynamically add rows",
            "Edit and Save buttons for row editing",
            "Remove button to delete rows",
            "Loading indicator for asynchronous operations"
        ]
    },
    "security_indicators": [
        "https",
        "Cross-origin resource sharing (CORS) for external assets",
        "No visible CAPTCHA but minimal user input fields reduce attack surface"
    ]
}
2025-05-07 20:02:07,929 - DEBUG - Sanitized LLM response: {
    "auth_requirements": {
        "auth_required": false,
        "auth_type": "none",
        "auth_fields": []
    },
    "contact_form_fields": [],
    "main_content": "The page provides a practice environment for reproducing and understanding common Selenium exceptions. It includes test cases for exceptions like NoSuchElementException, ElementNotInteractableException, InvalidElementStateException, StaleElementReferenceException, and TimeoutException. Users can interact with a dynamic list of favorite foods to simulate these exceptions.",
    "key_actions": [
        "Add a new row to the list",
        "Edit an existing row",
        "Save changes to a row",
        "Remove a row",
        "Interact with test cases for Selenium exceptions"
    ],
    "content_hierarchy": {
        "primary_sections": [
            "Test Exceptions Overview",
            "Favorite Foods List Interaction",
            "Test Cases for Selenium Exceptions"
        ],
        "subsections": [
            "Test case 1: NoSuchElementException",
            "Test case 2: ElementNotInteractableException",
            "Test case 3: InvalidElementStateException",
            "Test case 4: StaleElementReferenceException",
            "Test case 5: TimeoutException"
        ]
    },
    "interactive_patterns": {
        "forms": ["dynamic list interaction"],
        "dynamic_elements": [
            "Add button to dynamically add rows",
            "Edit and Save buttons for row editing",
            "Remove button to delete rows",
            "Loading indicator for asynchronous operations"
        ]
    },
    "security_indicators": [
        "https",
        "Cross-origin resource sharing (CORS) for external assets",
        "No visible CAPTCHA but minimal user input fields reduce attack surface"
    ]
}
2025-05-07 20:02:07,929 - DEBUG - LLM Analysed page metadata: {'auth_requirements': {'auth_required': False, 'auth_type': 'none', 'auth_fields': []}, 'contact_form_fields': [], 'main_content': 'The page provides a practice environment for reproducing and understanding common Selenium exceptions. It includes test cases for exceptions like NoSuchElementException, ElementNotInteractableException, InvalidElementStateException, StaleElementReferenceException, and TimeoutException. Users can interact with a dynamic list of favorite foods to simulate these exceptions.', 'key_actions': ['Add a new row to the list', 'Edit an existing row', 'Save changes to a row', 'Remove a row', 'Interact with test cases for Selenium exceptions'], 'content_hierarchy': {'primary_sections': ['Test Exceptions Overview', 'Favorite Foods List Interaction', 'Test Cases for Selenium Exceptions'], 'subsections': ['Test case 1: NoSuchElementException', 'Test case 2: ElementNotInteractableException', 'Test case 3: InvalidElementStateException', 'Test case 4: StaleElementReferenceException', 'Test case 5: TimeoutException']}, 'interactive_patterns': {'forms': ['dynamic list interaction'], 'dynamic_elements': ['Add button to dynamically add rows', 'Edit and Save buttons for row editing', 'Remove button to delete rows', 'Loading indicator for asynchronous operations']}, 'security_indicators': ['https', 'Cross-origin resource sharing (CORS) for external assets', 'No visible CAPTCHA but minimal user input fields reduce attack surface']}
2025-05-07 20:02:07,929 - DEBUG - Combined page metadata: {'title': 'Test Exceptions | Practice Test Automation', 'url': 'https://practicetestautomation.com/practice-test-exceptions/', 'forms': [], 'buttons': [{'tag': 'a', 'text': '', 'id': '', 'type': ''}, {'tag': 'a', 'text': '', 'id': '', 'type': ''}, {'tag': 'button', 'text': '', 'id': '', 'type': 'submit'}, {'tag': 'a', 'text': 'HOME', 'id': '', 'type': ''}, {'tag': 'a', 'text': 'PRACTICE', 'id': '', 'type': ''}, {'tag': 'a', 'text': 'COURSES', 'id': '', 'type': ''}, {'tag': 'a', 'text': 'BLOG', 'id': '', 'type': ''}, {'tag': 'a', 'text': 'CONTACT', 'id': '', 'type': ''}, {'tag': 'button', 'text': '', 'id': 'toggle-navigation', 'type': 'submit'}, {'tag': 'a', 'text': 'Selenium WebDriver with Java for beginners program', 'id': '', 'type': ''}, {'tag': 'input', 'text': '', 'id': '', 'type': 'text'}, {'tag': 'button', 'text': 'Edit', 'id': 'edit_btn', 'type': 'submit'}, {'tag': 'button', 'text': '', 'id': 'save_btn', 'type': 'submit'}, {'tag': 'button', 'text': 'Add', 'id': 'add_btn', 'type': 'submit'}, {'tag': 'a', 'text': 'Practice Test Automation.', 'id': '', 'type': ''}, {'tag': 'a', 'text': 'Privacy Policy', 'id': '', 'type': ''}], 'tables': [], 'key_flows': {'main_navigation': ['https://practicetestautomation.com/', 'https://practicetestautomation.com/practice/', 'https://practicetestautomation.com/courses/', 'https://practicetestautomation.com/blog/', 'https://practicetestautomation.com/contact/'], 'primary_actions': []}, 'auth_requirements': {'auth_required': False, 'auth_type': 'none', 'auth_fields': []}, 'contact_form_fields': [], 'main_content': 'The page provides a practice environment for reproducing and understanding common Selenium exceptions. It includes test cases for exceptions like NoSuchElementException, ElementNotInteractableException, InvalidElementStateException, StaleElementReferenceException, and TimeoutException. Users can interact with a dynamic list of favorite foods to simulate these exceptions.', 'key_actions': ['Add a new row to the list', 'Edit an existing row', 'Save changes to a row', 'Remove a row', 'Interact with test cases for Selenium exceptions'], 'content_hierarchy': {'primary_sections': ['Test Exceptions Overview', 'Favorite Foods List Interaction', 'Test Cases for Selenium Exceptions'], 'subsections': ['Test case 1: NoSuchElementException', 'Test case 2: ElementNotInteractableException', 'Test case 3: InvalidElementStateException', 'Test case 4: StaleElementReferenceException', 'Test case 5: TimeoutException']}, 'interactive_patterns': {'forms': ['dynamic list interaction'], 'dynamic_elements': ['Add button to dynamically add rows', 'Edit and Save buttons for row editing', 'Remove button to delete rows', 'Loading indicator for asynchronous operations']}, 'security_indicators': ['https', 'Cross-origin resource sharing (CORS) for external assets', 'No visible CAPTCHA but minimal user input fields reduce attack surface']}
2025-05-07 20:02:07,929 - INFO - Sending request to LLM for test case generation...
2025-05-07 20:02:27,842 - DEBUG - Raw LLM response: {
    "test_cases": [
        {
            "name": "Verify Add Button Functionality",
            "type": "functional",
            "steps": [
                "Open the page",
                "Click the 'Add' button",
                "Wait for Row 2 to appear"
            ],
            "selectors": {
                "add_button": "#add_btn",
                "row2": "#row2"
            },
            "validation": "Row 2 should be displayed after clicking the 'Add' button",
            "test_data": {}
        },
        {
            "name": "Verify Edit Button Enables Input Field",
            "type": "functional",
            "steps": [
                "Open the page",
                "Click the 'Edit' button for Row 1",
                "Verify the input field is enabled"
            ],
            "selectors": {
                "edit_button": "#edit_btn",
                "input_field": "#row1 input"
            },
            "validation": "The input field should be enabled for editing",
            "test_data": {}
        },
        {
            "name": "Verify Save Button Saves Input Value",
            "type": "functional",
            "steps": [
                "Open the page",
                "Click the 'Edit' button for Row 1",
                "Enter a new value in the input field",
                "Click the 'Save' button",
                "Verify the new value is saved"
            ],
            "selectors": {
                "edit_button": "#edit_btn",
                "save_button": "#save_btn",
                "input_field": "#row1 input"
            },
            "validation": "The new value should be saved and displayed in the input field",
            "test_data": {
                "input_value": "New Favorite Food"
            }
        },
        {
            "name": "Verify Row 2 Input Field is Displayed After Add",
            "type": "functional",
            "steps": [
                "Open the page",
                "Click the 'Add' button",
                "Wait for Row 2 input field to appear"
            ],
            "selectors": {
                "add_button": "#add_btn",
                "row2_input_field": "#row2 input"
            },
            "validation": "Row 2 input field should be displayed after clicking the 'Add' button",
            "test_data": {}
        },
        {
            "name": "Verify TimeoutException for Row 2 Input Field",
            "type": "functional",
            "steps": [
                "Open the page",
                "Click the 'Add' button",
                "Wait for 3 seconds for Row 2 input field to appear"
            ],
            "selectors": {
                "add_button": "#add_btn",
                "row2_input_field": "#row2 input"
            },
            "validation": "TimeoutException should occur as Row 2 input field takes longer than 3 seconds to appear",
            "test_data": {}
        },
        {
            "name": "Verify InvalidElementStateException for Disabled Input",
            "type": "functional",
            "steps": [
                "Open the page",
                "Attempt to clear the disabled input field in Row 1"
            ],
            "selectors": {
                "input_field": "#row1 input"
            },
            "validation": "InvalidElementStateException should be thrown when trying to clear a disabled input field",
            "test_data": {}
        },
        {
            "name": "Verify StaleElementReferenceException for Removed Element",
            "type": "functional",
            "steps": [
                "Open the page",
                "Find the instructions text element",
                "Click the 'Add' button",
                "Verify the instructions text element is no longer displayed"
            ],
            "selectors": {
                "instructions_text": "#instructions",
                "add_button": "#add_btn"
            },
            "validation": "StaleElementReferenceException should occur as the instructions text element is removed from the DOM",
            "test_data": {}
        },
        {
            "name": "Verify ElementNotInteractableException for Invisible Save Button",
            "type": "functional",
            "steps": [
                "Open the page",
                "Click the 'Add' button",
                "Attempt to click the invisible 'Save' button"
            ],
            "selectors": {
                "add_button": "#add_btn",
                "save_button": "#save_btn"
            },
            "validation": "ElementNotInteractableException should be thrown when trying to interact with an invisible 'Save' button",
            "test_data": {}
        },
        {
            "name": "Verify Remove Button Deletes Row 2",
            "type": "functional",
            "steps": [
                "Open the page",
                "Click the 'Add' button",
                "Wait for Row 2 to appear",
                "Click the 'Remove' button for Row 2",
                "Verify Row 2 is removed"
            ],
            "selectors": {
                "add_button": "#add_btn",
                "remove_button": "#row2 #remove_btn",
                "row2": "#row2"
            },
            "validation": "Row 2 should be removed after clicking the 'Remove' button",
            "test_data": {}
        },
        {
            "name": "Verify Navigation to Home Page",
            "type": "functional",
            "steps": [
                "Open the page",
                "Click the 'HOME' link in the navigation menu",
                "Verify the user is redirected to the home page"
            ],
            "selectors": {
                "home_link": "a[text='HOME']"
            },
            "validation": "The user should be redirected to the home page",
            "test_data": {}
        }
    ]
}
2025-05-07 20:02:27,843 - INFO - Received response from LLM
2025-05-07 20:02:27,843 - INFO - Successfully parsed 10 test cases
2025-05-07 20:02:27,843 - DEBUG - Test Case Details:
[
  {
    "name": "Verify Add Button Functionality",
    "type": "functional",
    "steps": [
      "Open the page",
      "Click the 'Add' button",
      "Wait for Row 2 to appear"
    ],
    "selectors": {
      "add_button": "#add_btn",
      "row2": "#row2"
    },
    "validation": "Row 2 should be displayed after clicking the 'Add' button",
    "test_data": {}
  },
  {
    "name": "Verify Edit Button Enables Input Field",
    "type": "functional",
    "steps": [
      "Open the page",
      "Click the 'Edit' button for Row 1",
      "Verify the input field is enabled"
    ],
    "selectors": {
      "edit_button": "#edit_btn",
      "input_field": "#row1 input"
    },
    "validation": "The input field should be enabled for editing",
    "test_data": {}
  },
  {
    "name": "Verify Save Button Saves Input Value",
    "type": "functional",
    "steps": [
      "Open the page",
      "Click the 'Edit' button for Row 1",
      "Enter a new value in the input field",
      "Click the 'Save' button",
      "Verify the new value is saved"
    ],
    "selectors": {
      "edit_button": "#edit_btn",
      "save_button": "#save_btn",
      "input_field": "#row1 input"
    },
    "validation": "The new value should be saved and displayed in the input field",
    "test_data": {
      "input_value": "New Favorite Food"
    }
  },
  {
    "name": "Verify Row 2 Input Field is Displayed After Add",
    "type": "functional",
    "steps": [
      "Open the page",
      "Click the 'Add' button",
      "Wait for Row 2 input field to appear"
    ],
    "selectors": {
      "add_button": "#add_btn",
      "row2_input_field": "#row2 input"
    },
    "validation": "Row 2 input field should be displayed after clicking the 'Add' button",
    "test_data": {}
  },
  {
    "name": "Verify TimeoutException for Row 2 Input Field",
    "type": "functional",
    "steps": [
      "Open the page",
      "Click the 'Add' button",
      "Wait for 3 seconds for Row 2 input field to appear"
    ],
    "selectors": {
      "add_button": "#add_btn",
      "row2_input_field": "#row2 input"
    },
    "validation": "TimeoutException should occur as Row 2 input field takes longer than 3 seconds to appear",
    "test_data": {}
  },
  {
    "name": "Verify InvalidElementStateException for Disabled Input",
    "type": "functional",
    "steps": [
      "Open the page",
      "Attempt to clear the disabled input field in Row 1"
    ],
    "selectors": {
      "input_field": "#row1 input"
    },
    "validation": "InvalidElementStateException should be thrown when trying to clear a disabled input field",
    "test_data": {}
  },
  {
    "name": "Verify StaleElementReferenceException for Removed Element",
    "type": "functional",
    "steps": [
      "Open the page",
      "Find the instructions text element",
      "Click the 'Add' button",
      "Verify the instructions text element is no longer displayed"
    ],
    "selectors": {
      "instructions_text": "#instructions",
      "add_button": "#add_btn"
    },
    "validation": "StaleElementReferenceException should occur as the instructions text element is removed from the DOM",
    "test_data": {}
  },
  {
    "name": "Verify ElementNotInteractableException for Invisible Save Button",
    "type": "functional",
    "steps": [
      "Open the page",
      "Click the 'Add' button",
      "Attempt to click the invisible 'Save' button"
    ],
    "selectors": {
      "add_button": "#add_btn",
      "save_button": "#save_btn"
    },
    "validation": "ElementNotInteractableException should be thrown when trying to interact with an invisible 'Save' button",
    "test_data": {}
  },
  {
    "name": "Verify Remove Button Deletes Row 2",
    "type": "functional",
    "steps": [
      "Open the page",
      "Click the 'Add' button",
      "Wait for Row 2 to appear",
      "Click the 'Remove' button for Row 2",
      "Verify Row 2 is removed"
    ],
    "selectors": {
      "add_button": "#add_btn",
      "remove_button": "#row2 #remove_btn",
      "row2": "#row2"
    },
    "validation": "Row 2 should be removed after clicking the 'Remove' button",
    "test_data": {}
  },
  {
    "name": "Verify Navigation to Home Page",
    "type": "functional",
    "steps": [
      "Open the page",
      "Click the 'HOME' link in the navigation menu",
      "Verify the user is redirected to the home page"
    ],
    "selectors": {
      "home_link": "a[text='HOME']"
    },
    "validation": "The user should be redirected to the home page",
    "test_data": {}
  }
]
2025-05-07 20:02:47,915 - DEBUG - Raw LLM response generated code: ```python
import logging
import sys
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    TimeoutException,
    NoSuchElementException,
    ElementClickInterceptedException,
    StaleElementReferenceException,
    WebDriverException,
)
from webdriver_manager.chrome import ChromeDriverManager

# Logging configuration
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

URL = "https://practicetestautomation.com/practice-test-exceptions/"
ADD_BUTTON_SELECTOR = "#add_btn"
ROW2_SELECTOR = "#row2"

MAX_RETRIES = 2
WAIT_TIMEOUT = 10

def retry_on_exception(func):
    def wrapper(*args, **kwargs):
        last_exception = None
        for attempt in range(1, MAX_RETRIES + 1):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                last_exception = e
                logging.warning(f"Attempt {attempt} failed: {e}")
                if attempt < MAX_RETRIES:
                    time.sleep(1)
        logging.error(f"All {MAX_RETRIES} attempts failed.")
        raise last_exception
    return wrapper

@retry_on_exception
def click_add_button(driver):
    logging.info("Waiting for 'Add' button to be clickable...")
    add_btn = WebDriverWait(driver, WAIT_TIMEOUT).until(
        EC.element_to_be_clickable((By.CSS_SELECTOR, ADD_BUTTON_SELECTOR))
    )
    logging.info("Clicking 'Add' button.")
    add_btn.click()

@retry_on_exception
def wait_for_row2(driver):
    logging.info("Waiting for Row 2 to appear...")
    row2 = WebDriverWait(driver, WAIT_TIMEOUT + 6).until(
        EC.visibility_of_element_located((By.CSS_SELECTOR, ROW2_SELECTOR))
    )
    logging.info("Row 2 is now visible.")
    return row2

def main():
    # WebDriver setup (Selenium 4.15.2 pattern)
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service)
    driver.maximize_window()
    test_passed = False

    try:
        logging.info(f"Opening page: {URL}")
        driver.get(URL)

        click_add_button(driver)
        row2 = wait_for_row2(driver)

        if row2.is_displayed():
            logging.info("Validation PASSED: Row 2 is displayed after clicking 'Add' button.")
            test_passed = True
        else:
            logging.error("Validation FAILED: Row 2 is not displayed after clicking 'Add' button.")

    except (TimeoutException, NoSuchElementException, WebDriverException, StaleElementReferenceException) as e:
        logging.error(f"Test failed due to exception: {e}")
    finally:
        driver.quit()
        if test_passed:
            logging.info("TEST RESULT: PASS")
        else:
            logging.info("TEST RESULT: FAIL")

if __name__ == "__main__":
    main()
```
2025-05-07 20:02:47,916 - INFO - Saved test script: test_scripts/test_20250507_200247_Verify_Add_Button_Functionality.py
2025-05-07 20:02:58,792 - DEBUG - Raw LLM response generated code: ```python
import logging
import sys
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    TimeoutException,
    ElementClickInterceptedException,
    ElementNotInteractableException,
    StaleElementReferenceException,
    WebDriverException,
)
from webdriver_manager.chrome import ChromeDriverManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

URL = "https://practicetestautomation.com/practice-test-exceptions/"
EDIT_BUTTON_SELECTOR = "#edit_btn"
INPUT_FIELD_SELECTOR = "#row1 input"

MAX_RETRIES = 2
WAIT_TIMEOUT = 10

def retry_on_exception(func):
    def wrapper(*args, **kwargs):
        last_exception = None
        for attempt in range(1, MAX_RETRIES + 1):
            try:
                return func(*args, **kwargs)
            except (ElementClickInterceptedException, ElementNotInteractableException, StaleElementReferenceException, TimeoutException, WebDriverException) as e:
                logging.warning(f"Attempt {attempt} failed with exception: {e}")
                last_exception = e
                time.sleep(1)
        logging.error(f"All {MAX_RETRIES} attempts failed for {func.__name__}")
        raise last_exception
    return wrapper

@retry_on_exception
def click_edit_button(driver):
    logging.info("Waiting for Edit button to be clickable...")
    edit_btn = WebDriverWait(driver, WAIT_TIMEOUT).until(
        EC.element_to_be_clickable((By.CSS_SELECTOR, EDIT_BUTTON_SELECTOR))
    )
    logging.info("Clicking Edit button for Row 1.")
    edit_btn.click()

@retry_on_exception
def verify_input_enabled(driver):
    logging.info("Waiting for Row 1 input field to be present...")
    input_field = WebDriverWait(driver, WAIT_TIMEOUT).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, INPUT_FIELD_SELECTOR))
    )
    logging.info("Checking if input field is enabled...")
    if input_field.is_enabled():
        logging.info("SUCCESS: Input field is enabled for editing.")
        return True
    else:
        logging.error("FAIL: Input field is NOT enabled after clicking Edit.")
        return False

def main():
    # WebDriver setup for Selenium 4.15.2
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service)
    driver.maximize_window()
    test_passed = False

    try:
        logging.info(f"Opening page: {URL}")
        driver.get(URL)

        # Step 1: Click the 'Edit' button for Row 1
        click_edit_button(driver)

        # Step 2: Verify the input field is enabled
        if verify_input_enabled(driver):
            logging.info("Test case PASSED: The input field is enabled for editing after clicking Edit.")
            test_passed = True
        else:
            logging.error("Test case FAILED: The input field is not enabled after clicking Edit.")

    except Exception as e:
        logging.exception(f"Test execution failed: {e}")
    finally:
        driver.quit()
        if test_passed:
            logging.info("TEST RESULT: PASS")
            sys.exit(0)
        else:
            logging.error("TEST RESULT: FAIL")
            sys.exit(1)

if __name__ == "__main__":
    main()
```
2025-05-07 20:02:58,793 - INFO - Saved test script: test_scripts/test_20250507_200258_Verify_Edit_Button_Enables_Input_Field.py
2025-05-07 20:03:16,585 - DEBUG - Raw LLM response generated code: ```python
import logging
import sys
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    TimeoutException,
    ElementClickInterceptedException,
    ElementNotInteractableException,
    StaleElementReferenceException,
    WebDriverException,
)
from webdriver_manager.chrome import ChromeDriverManager

# --- Logging Setup ---
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("TestSaveButton")

# --- Test Data ---
TEST_URL = "https://practicetestautomation.com/practice-test-exceptions/"
EDIT_BTN_SELECTOR = (By.CSS_SELECTOR, "#edit_btn")
SAVE_BTN_SELECTOR = (By.CSS_SELECTOR, "#save_btn")
INPUT_FIELD_SELECTOR = (By.CSS_SELECTOR, "#row1 input")
NEW_INPUT_VALUE = "New Favorite Food"
RETRY_COUNT = 2
WAIT_TIMEOUT = 10

def retry_on_exception(max_retries=RETRY_COUNT, exceptions=(Exception,)):
    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exc = None
            for attempt in range(1, max_retries + 1):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    logger.warning(f"Attempt {attempt} failed: {e}")
                    last_exc = e
                    time.sleep(1)
            logger.error(f"All {max_retries} attempts failed for {func.__name__}")
            raise last_exc
        return wrapper
    return decorator

@retry_on_exception(max_retries=RETRY_COUNT, exceptions=(ElementClickInterceptedException, ElementNotInteractableException, StaleElementReferenceException))
def click_element(driver, locator, description, timeout=WAIT_TIMEOUT):
    logger.info(f"Clicking {description} ({locator})")
    element = WebDriverWait(driver, timeout).until(
        EC.element_to_be_clickable(locator)
    )
    element.click()

@retry_on_exception(max_retries=RETRY_COUNT, exceptions=(ElementNotInteractableException, StaleElementReferenceException))
def clear_and_type(driver, locator, value, description, timeout=WAIT_TIMEOUT):
    logger.info(f"Clearing and typing into {description} ({locator})")
    input_elem = WebDriverWait(driver, timeout).until(
        EC.visibility_of_element_located(locator)
    )
    input_elem.clear()
    input_elem.send_keys(value)

def main():
    logger.info("Initializing WebDriver (Selenium 4.15.2)...")
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service)
    driver.maximize_window()
    test_passed = False

    try:
        logger.info(f"Opening test page: {TEST_URL}")
        driver.get(TEST_URL)

        # Step 1: Click the 'Edit' button for Row 1
        click_element(driver, EDIT_BTN_SELECTOR, "Edit button for Row 1")

        # Step 2: Enter a new value in the input field
        logger.info("Waiting for input field to be enabled and visible...")
        input_field = WebDriverWait(driver, WAIT_TIMEOUT).until(
            lambda d: d.find_element(*INPUT_FIELD_SELECTOR)
        )
        WebDriverWait(driver, WAIT_TIMEOUT).until(
            lambda d: not input_field.get_attribute("disabled")
        )
        clear_and_type(driver, INPUT_FIELD_SELECTOR, NEW_INPUT_VALUE, "Row 1 input field")

        # Step 3: Click the 'Save' button
        click_element(driver, SAVE_BTN_SELECTOR, "Save button for Row 1")

        # Step 4: Verify the new value is saved and displayed in the input field
        logger.info("Verifying the new value is saved in the input field...")
        def input_value_is_saved(driver):
            elem = driver.find_element(*INPUT_FIELD_SELECTOR)
            return elem.get_attribute("value") == NEW_INPUT_VALUE and elem.get_attribute("disabled") == "true"

        WebDriverWait(driver, WAIT_TIMEOUT).until(input_value_is_saved)
        logger.info("Test PASSED: The new value was saved and displayed in the input field.")
        test_passed = True

    except (TimeoutException, WebDriverException, AssertionError) as e:
        logger.error(f"Test FAILED: {e}")
    finally:
        driver.quit()
        if not test_passed:
            sys.exit(1)

if __name__ == "__main__":
    main()
```
2025-05-07 20:03:16,586 - INFO - Saved test script: test_scripts/test_20250507_200316_Verify_Save_Button_Saves_Input_Value.py
2025-05-07 20:03:26,415 - DEBUG - Raw LLM response generated code: ```python
import logging
import sys
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    TimeoutException,
    NoSuchElementException,
    ElementClickInterceptedException,
    StaleElementReferenceException,
    WebDriverException,
)
from webdriver_manager.chrome import ChromeDriverManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

URL = "https://practicetestautomation.com/practice-test-exceptions/"
ADD_BUTTON_SELECTOR = "#add_btn"
ROW2_INPUT_SELECTOR = "#row2 input"

def retry(action, retries=3, delay=2, exceptions=(Exception,), action_desc=""):
    for attempt in range(1, retries + 1):
        try:
            return action()
        except exceptions as e:
            logging.warning(f"Attempt {attempt} failed for '{action_desc}': {e}")
            if attempt == retries:
                logging.error(f"All {retries} attempts failed for '{action_desc}'.")
                raise
            time.sleep(delay)

def main():
    logging.info("Initializing WebDriver for Selenium 4.15.2")
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service)
    driver.maximize_window()
    wait = WebDriverWait(driver, 15)

    try:
        # Step 1: Open the page
        logging.info(f"Opening page: {URL}")
        driver.get(URL)

        # Step 2: Click the 'Add' button with retry logic
        def click_add():
            add_btn = wait.until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, ADD_BUTTON_SELECTOR))
            )
            add_btn.click()
            logging.info("Clicked the 'Add' button.")
        retry(click_add, retries=3, delay=2, exceptions=(TimeoutException, ElementClickInterceptedException), action_desc="Click 'Add' button")

        # Step 3: Wait for Row 2 input field to appear
        def wait_for_row2_input():
            logging.info("Waiting for Row 2 input field to be present and visible (may take ~5 seconds)...")
            input_elem = wait.until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, ROW2_INPUT_SELECTOR))
            )
            logging.info("Row 2 input field is now visible.")
            return input_elem
        row2_input = retry(wait_for_row2_input, retries=2, delay=1, exceptions=(TimeoutException, StaleElementReferenceException), action_desc="Wait for Row 2 input field")

        # Validation: Row 2 input field should be displayed
        if row2_input.is_displayed():
            logging.info("TEST PASSED: Row 2 input field is displayed after clicking the 'Add' button.")
        else:
            logging.error("TEST FAILED: Row 2 input field is NOT displayed after clicking the 'Add' button.")
            raise AssertionError("Row 2 input field not displayed.")

    except Exception as e:
        logging.exception(f"Test failed due to exception: {e}")
    finally:
        driver.quit()
        logging.info("WebDriver session closed.")

if __name__ == "__main__":
    main()
```
2025-05-07 20:03:26,416 - INFO - Saved test script: test_scripts/test_20250507_200326_Verify_Row_2_Input_Field_is_Displayed_After_Add.py
2025-05-07 20:03:34,542 - DEBUG - Raw LLM response generated code: ```python
import logging
import sys
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
from webdriver_manager.chrome import ChromeDriverManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

def main():
    url = "https://practicetestautomation.com/practice-test-exceptions/"
    selectors = {
        "add_button": "#add_btn",
        "row2_input_field": "#row2 input"
    }

    # WebDriver setup for Selenium 4.15.2
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service)
    driver.maximize_window()

    try:
        logging.info("Opening page: %s", url)
        driver.get(url)

        # Wait for Add button to be present and clickable
        try:
            add_btn = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, selectors["add_button"]))
            )
            logging.info("Add button found and clickable.")
        except TimeoutException:
            logging.error("Add button not found or not clickable.")
            driver.quit()
            return

        # Click the Add button
        logging.info("Clicking the Add button.")
        add_btn.click()

        # Attempt to wait for Row 2 input field for only 3 seconds
        logging.info("Waiting up to 3 seconds for Row 2 input field to appear (should timeout).")
        try:
            WebDriverWait(driver, 3).until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, selectors["row2_input_field"]))
            )
            logging.error("Row 2 input field appeared within 3 seconds (unexpected). Test FAILED.")
        except TimeoutException:
            logging.info("TimeoutException occurred as expected. Row 2 input field did not appear within 3 seconds. Test PASSED.")

    except Exception as e:
        logging.exception("Unexpected error during test execution: %s", e)
    finally:
        logging.info("Closing browser.")
        driver.quit()

if __name__ == "__main__":
    main()
```
2025-05-07 20:03:34,543 - INFO - Saved test script: test_scripts/test_20250507_200334_Verify_TimeoutException_for_Row_2_Input_Field.py
2025-05-07 20:03:47,509 - DEBUG - Raw LLM response generated code: ```python
import logging
import sys
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    InvalidElementStateException,
    TimeoutException,
    WebDriverException,
)
from webdriver_manager.chrome import ChromeDriverManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

def main():
    url = "https://practicetestautomation.com/practice-test-exceptions/"
    input_selector = (By.CSS_SELECTOR, "#row1 input")
    max_retries = 2
    driver = None

    # WebDriver initialization (Selenium 4.15.2 best practice)
    try:
        service = Service(ChromeDriverManager().install())
        driver = webdriver.Chrome(service=service)
        driver.maximize_window()
        logging.info("WebDriver started successfully.")
    except WebDriverException as e:
        logging.error(f"Failed to start WebDriver: {e}")
        sys.exit(1)

    try:
        # Step 1: Open the page
        logging.info(f"Opening URL: {url}")
        driver.get(url)

        # Step 2: Wait for the disabled input field in Row 1 to be present
        wait = WebDriverWait(driver, 10)
        input_field = wait.until(
            EC.presence_of_element_located(input_selector)
        )
        logging.info("Located Row 1 input field.")

        # Step 3: Attempt to clear the disabled input field and expect InvalidElementStateException
        for attempt in range(1, max_retries + 1):
            try:
                logging.info(f"Attempt {attempt}: Trying to clear the disabled input field.")
                input_field.clear()
                # If no exception, this is a failure for this test case
                logging.error("Expected InvalidElementStateException was NOT thrown when clearing a disabled input field.")
                print("[FAIL] InvalidElementStateException was NOT thrown when clearing a disabled input field.")
                break
            except InvalidElementStateException:
                logging.info("InvalidElementStateException was correctly thrown when trying to clear a disabled input field.")
                print("[PASS] InvalidElementStateException was thrown as expected.")
                break
            except Exception as e:
                logging.warning(f"Unexpected exception occurred: {type(e).__name__}: {e}")
                if attempt == max_retries:
                    logging.error("Max retries reached. Test failed due to unexpected exception.")
                    print(f"[FAIL] Unexpected exception: {type(e).__name__}: {e}")
                else:
                    time.sleep(1)
    finally:
        if driver:
            driver.quit()
            logging.info("WebDriver session closed.")

if __name__ == "__main__":
    main()
```
2025-05-07 20:03:47,510 - INFO - Saved test script: test_scripts/test_20250507_200347_Verify_InvalidElementStateException_for_Disabled_Input.py
2025-05-07 20:04:01,436 - DEBUG - Raw LLM response generated code: ```python
import logging
import sys
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    StaleElementReferenceException,
    TimeoutException,
    WebDriverException,
)
from webdriver_manager.chrome import ChromeDriverManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)]
)

URL = "https://practicetestautomation.com/practice-test-exceptions/"
SELECTORS = {
    "instructions_text": "#instructions",
    "add_button": "#add_btn"
}
WAIT_TIMEOUT = 10
RETRY_COUNT = 2

def main():
    # WebDriver setup for Selenium 4.15.2
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service)
    driver.maximize_window()
    try:
        logging.info("Opening page: %s", URL)
        driver.get(URL)

        # Step 1: Find the instructions text element
        logging.info("Waiting for instructions text element to be present")
        instructions = WebDriverWait(driver, WAIT_TIMEOUT).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, SELECTORS["instructions_text"]))
        )
        logging.info("Instructions text element found: %s", instructions.text)

        # Step 2: Click the 'Add' button
        logging.info("Waiting for Add button to be clickable")
        add_btn = WebDriverWait(driver, WAIT_TIMEOUT).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, SELECTORS["add_button"]))
        )
        logging.info("Clicking the Add button")
        add_btn.click()

        # Step 3: Wait for the instructions element to be removed from DOM
        logging.info("Waiting for instructions text element to be removed from DOM")
        WebDriverWait(driver, WAIT_TIMEOUT).until(
            EC.staleness_of(instructions)
        )
        logging.info("Instructions text element has been removed from DOM")

        # Step 4: Attempt to interact with the stale element to trigger StaleElementReferenceException
        stale_exception_raised = False
        for attempt in range(1, RETRY_COUNT + 1):
            try:
                logging.info("Attempt #%d: Accessing instructions text element after removal", attempt)
                # This should raise StaleElementReferenceException
                _ = instructions.text
                logging.warning("No exception raised when accessing stale element (unexpected)")
            except StaleElementReferenceException:
                logging.info("StaleElementReferenceException correctly raised when accessing removed element")
                stale_exception_raised = True
                break
            except Exception as e:
                logging.error("Unexpected exception: %s", e)
                break
            time.sleep(1)

        if stale_exception_raised:
            logging.info("TEST PASSED: StaleElementReferenceException was raised as expected.")
        else:
            logging.error("TEST FAILED: StaleElementReferenceException was NOT raised.")

    except TimeoutException as e:
        logging.error("Timeout waiting for element: %s", e)
    except WebDriverException as e:
        logging.error("WebDriver error: %s", e)
    except Exception as e:
        logging.error("Unexpected error: %s", e)
    finally:
        driver.quit()
        logging.info("Test completed and browser closed.")

if __name__ == "__main__":
    main()
```
2025-05-07 20:04:01,444 - INFO - Saved test script: test_scripts/test_20250507_200401_Verify_StaleElementReferenceException_for_Removed_Element.py
2025-05-07 20:04:38,299 - DEBUG - Raw LLM response generated code: ```python
import logging
import sys
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    ElementNotInteractableException,
    TimeoutException,
    WebDriverException,
)
from webdriver_manager.chrome import ChromeDriverManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

def retry_on_exception(exception, tries=3, delay=1.0):
    """
    Decorator to retry a function if a specific exception is raised.
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exc = None
            for attempt in range(1, tries + 1):
                try:
                    return func(*args, **kwargs)
                except exception as exc:
                    last_exc = exc
                    logging.warning(f"Attempt {attempt} failed with {exception.__name__}: {exc}")
                    time.sleep(delay)
            raise last_exc
        return wrapper
    return decorator

@retry_on_exception(WebDriverException, tries=2, delay=2.0)
def main():
    # WebDriver setup (Selenium 4.15.2 best practice)
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service)
    driver.maximize_window()
    wait = WebDriverWait(driver, 15)

    url = "https://practicetestautomation.com/practice-test-exceptions/"
    logging.info(f"Opening page: {url}")
    driver.get(url)

    try:
        # Step 1: Click the 'Add' button
        logging.info("Waiting for 'Add' button to be clickable...")
        add_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "#add_btn")))
        logging.info("Clicking 'Add' button.")
        add_button.click()

        # Step 2: Attempt to click the invisible 'Save' button (Row 1)
        # The save button for row 1 is present but hidden (display: none)
        logging.info("Locating invisible 'Save' button for Row 1.")
        save_button = driver.find_element(By.CSS_SELECTOR, "#save_btn")

        # Confirm the button is not displayed
        if save_button.is_displayed():
            logging.error("The 'Save' button is visible, test cannot proceed as expected.")
            driver.quit()
            sys.exit(1)
        else:
            logging.info("'Save' button is invisible as expected. Attempting to click it to trigger ElementNotInteractableException.")

        # Step 3: Attempt to click and expect ElementNotInteractableException
        exception_raised = False
        try:
            save_button.click()
        except ElementNotInteractableException as e:
            logging.info("ElementNotInteractableException was thrown as expected when clicking invisible 'Save' button.")
            exception_raised = True
        except Exception as e:
            logging.error(f"Unexpected exception type: {type(e).__name__}: {e}")
            raise

        if not exception_raised:
            logging.error("ElementNotInteractableException was NOT thrown when clicking invisible 'Save' button. Test FAILED.")
            driver.quit()
            sys.exit(2)
        else:
            logging.info("Test PASSED: ElementNotInteractableException correctly thrown for invisible 'Save' button.")

    finally:
        driver.quit()
        logging.info("WebDriver session closed.")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logging.error(f"Test execution failed: {e}")
        sys.exit(99)
```
2025-05-07 20:04:38,300 - INFO - Saved test script: test_scripts/test_20250507_200438_Verify_ElementNotInteractableException_for_Invisible_Save_Button.py
2025-05-07 20:04:50,588 - DEBUG - Raw LLM response generated code: ```python
import logging
import sys
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    TimeoutException,
    NoSuchElementException,
    ElementClickInterceptedException,
    StaleElementReferenceException,
    WebDriverException,
)
from webdriver_manager.chrome import ChromeDriverManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

URL = "https://practicetestautomation.com/practice-test-exceptions/"
SELECTORS = {
    "add_button": (By.CSS_SELECTOR, "#add_btn"),
    "row2": (By.CSS_SELECTOR, "#row2"),
    "remove_button": (By.CSS_SELECTOR, "#row2 #remove_btn"),
}

def wait_for_element(driver, locator, timeout=10, poll_frequency=0.5, disappear=False):
    """
    Wait for element to appear or disappear.
    """
    try:
        wait = WebDriverWait(driver, timeout, poll_frequency)
        if not disappear:
            return wait.until(EC.presence_of_element_located(locator))
        else:
            return wait.until(EC.invisibility_of_element_located(locator))
    except TimeoutException:
        if not disappear:
            logging.error(f"Timeout: Element {locator} not found after {timeout}s")
        else:
            logging.error(f"Timeout: Element {locator} still visible after {timeout}s")
        return None

def click_with_retry(driver, locator, retries=3, delay=1):
    """
    Click an element with retries and logging.
    """
    for attempt in range(1, retries + 1):
        try:
            elem = wait_for_element(driver, locator, timeout=10)
            if elem:
                elem.click()
                logging.info(f"Clicked element {locator}")
                return True
            else:
                logging.warning(f"Element {locator} not found on attempt {attempt}")
        except (ElementClickInterceptedException, StaleElementReferenceException, WebDriverException) as e:
            logging.warning(f"Attempt {attempt}: Error clicking {locator}: {e}")
            time.sleep(delay)
    logging.error(f"Failed to click element {locator} after {retries} attempts")
    return False

def verify_row2_removed(driver, timeout=5):
    """
    Verify that Row 2 is removed (not present or not displayed).
    """
    try:
        wait = WebDriverWait(driver, timeout, poll_frequency=0.5)
        result = wait.until(EC.invisibility_of_element_located(SELECTORS["row2"]))
        if result:
            logging.info("Row 2 is removed (not visible).")
            return True
        else:
            logging.error("Row 2 is still visible after removal.")
            return False
    except TimeoutException:
        logging.error("Timeout waiting for Row 2 to be removed.")
        return False

def main():
    # WebDriver setup (Selenium 4.15.2 recommended pattern)
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service)
    driver.maximize_window()

    test_passed = False

    try:
        logging.info("Opening the test page...")
        driver.get(URL)

        # Step 1: Click the 'Add' button
        logging.info("Clicking the 'Add' button to add Row 2.")
        if not click_with_retry(driver, SELECTORS["add_button"]):
            raise Exception("Could not click 'Add' button.")

        # Step 2: Wait for Row 2 to appear (it takes ~5s)
        logging.info("Waiting for Row 2 to appear...")
        row2_elem = wait_for_element(driver, SELECTORS["row2"], timeout=10)
        if not row2_elem:
            raise Exception("Row 2 did not appear after clicking 'Add'.")

        # Step 3: Click the 'Remove' button for Row 2
        logging.info("Clicking the 'Remove' button for Row 2.")
        if not click_with_retry(driver, SELECTORS["remove_button"]):
            raise Exception("Could not click 'Remove' button for Row 2.")

        # Step 4: Verify Row 2 is removed
        logging.info("Verifying that Row 2 is removed...")
        if verify_row2_removed(driver, timeout=5):
            logging.info("TEST PASSED: Row 2 was successfully removed.")
            test_passed = True
        else:
            logging.error("TEST FAILED: Row 2 was not removed.")

    except Exception as e:
        logging.exception(f"Test encountered an error: {e}")
    finally:
        driver.quit()
        if test_passed:
            logging.info("Test completed successfully.")
        else:
            logging.error("Test failed.")

if __name__ == "__main__":
    main()
```
2025-05-07 20:04:50,588 - INFO - Saved test script: test_scripts/test_20250507_200450_Verify_Remove_Button_Deletes_Row_2.py
2025-05-07 20:05:00,827 - DEBUG - Raw LLM response generated code: ```python
import logging
import sys
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    TimeoutException,
    NoSuchElementException,
    ElementClickInterceptedException,
    StaleElementReferenceException,
    WebDriverException,
)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

HOME_PAGE_URL = "https://practicetestautomation.com/"
EXCEPTIONS_PAGE_URL = "https://practicetestautomation.com/practice-test-exceptions/"
HOME_LINK_XPATH = "//nav[contains(@class, 'menu') or @class='menu']//a[normalize-space(text())='Home']"

def retry_on_exception(max_retries=3, exceptions=(Exception,), delay=1.0):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(1, max_retries + 1):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    logging.warning(f"Attempt {attempt} failed: {e}")
                    if attempt == max_retries:
                        raise
                    time.sleep(delay)
        return wrapper
    return decorator

@retry_on_exception(max_retries=2, exceptions=(WebDriverException, TimeoutException, StaleElementReferenceException), delay=2)
def click_home_link(driver):
    logging.info("Waiting for the 'Home' link to be visible in the navigation menu...")
    home_link = WebDriverWait(driver, 10).until(
        EC.element_to_be_clickable((By.XPATH, HOME_LINK_XPATH))
    )
    logging.info("Clicking the 'Home' link in the navigation menu.")
    home_link.click()

def verify_home_page_loaded(driver):
    logging.info("Verifying redirection to the home page...")
    try:
        WebDriverWait(driver, 10).until(
            EC.url_to_be(HOME_PAGE_URL)
        )
        # Optionally, verify the page title or a unique element on the home page
        WebDriverWait(driver, 10).until(
            EC.title_contains("Practice Test Automation")
        )
        logging.info("Successfully redirected to the home page.")
        return True
    except TimeoutException:
        logging.error(f"Failed to verify redirection. Current URL: {driver.current_url}")
        return False

def main():
    # Selenium 4.15.2 WebDriver initialization
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service)
    driver.maximize_window()
    test_passed = False

    try:
        logging.info(f"Opening the Exceptions Practice page: {EXCEPTIONS_PAGE_URL}")
        driver.get(EXCEPTIONS_PAGE_URL)

        click_home_link(driver)

        if verify_home_page_loaded(driver):
            logging.info("TEST PASSED: User is redirected to the home page.")
            test_passed = True
        else:
            logging.error("TEST FAILED: User was not redirected to the home page.")

    except Exception as e:
        logging.exception(f"TEST ERROR: {e}")
    finally:
        driver.quit()
        if test_passed:
            logging.info("Test case 'Verify Navigation to Home Page' completed successfully.")
        else:
            logging.error("Test case 'Verify Navigation to Home Page' failed.")

if __name__ == "__main__":
    main()
```
2025-05-07 20:05:00,835 - INFO - Saved test script: test_scripts/test_20250507_200500_Verify_Navigation_to_Home_Page.py
2025-05-07 20:06:58,736 - INFO - Navigation tracking completed
